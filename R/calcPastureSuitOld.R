#' @title calcPastureSuit
#' @description Calculate glassland suitable for pasture management based
#' on population and aridity criteria.
#'
#' @param lpjml Defines LPJmL version for crop/grass and natveg specific inputs
#' @param climatetype   Switch between different climate scenarios
#'
#' @return List of magpie object with results on cluster level
#' @author Marcos Alves
#' @examples
#' \dontrun{
#' calcOutput("PastureSuitOld")
#' }
#' @importFrom raster area rasterFromXYZ

calcPastureSuitOld <- function(climatetype = "MRI-ESM2-0:ssp126", lpjml =  "LPJmL4_for_MAgPIE_44ac93de") {

  x <- toolSplitSubtype(climatetype, list(climatemodel = NULL, scenario = NULL))

  # Extract stage argument information
  if (grepl("GSWP3-W5E5", climatetype)) {
    stage <- "smoothed"
  } else {
    stage <- "harmonized2020"
  }

  # Drivers of managed pastures
  population <- calcOutput("GridPop", subtype = "all", cellular = TRUE, FiveYear = TRUE,
                           harmonize_until = 2015,
                           aggregate = FALSE)[, , toupper(substring(x$scenario, first = 0, last = 4))]

  cellPrep   <- calcOutput("LPJmLClimateInput", climatetype  = climatetype,
                           variable     = "precipitation:monthlySum",
                           stage        = stage,
                           lpjmlVersion = lpjml,
                           aggregate    = FALSE)


  cellPet    <- calcOutput(type = "LPJmL_new", climatetype = climatetype,
                           subtype   = "mpet",
                           stage     = stage,
                           version   = lpjml,
                           aggregate = FALSE)

  cellPrep <- mrwater::toolLPJcell2MAgPIEcell(cellPrep)
  cellPet  <- mrwater::toolLPJcell2MAgPIEcell(cellPet)

  yearsCellPet      <- intersect(getYears(cellPet), findset("time"))
  yearsCellPrep     <- intersect(findset("time"), getYears(cellPrep))
  years             <- intersect(yearsCellPet, yearsCellPrep)
  cellPrep          <- dimSums(cellPrep[, years, ], dim = 3)
  cellPet           <- dimSums(cellPet[, years, ], dim = 3)

  # Cell area calculation

  land <- calcOutput("LanduseInitialisation", input_magpie = TRUE,
                   aggregate = FALSE, cellular = TRUE, cells = cells,
                   years = "y1995", round = 6)
  landArea <- setYears(dimSums(land, dim = 3), NULL)

  #after merging to
  #landArea <- calcOutput("LandArea", aggregate = FALSE) / 100 # transformed to km^2 #nolint

  # population density
  population <- population[getCells(cellPet), , ] # fixing the order of the population cells (should not be necessary!)
  popDensity <- (population * 1e6) / landArea # population density in number of people per km2
  popDensity[is.infinite(popDensity)] <- 0
  popDensity[is.nan(popDensity)] <- 0

  years <- intersect(getYears(popDensity), getYears(cellPrep))

  aridity <- cellPrep[, years, ] / cellPet[, years, ]
  aridity[is.infinite(aridity) | is.nan(aridity)] <- 0
  # 0.5 aridity threshold for managed pastures. Same from HYDE 3.2.
  aridity[aridity < 0.5] <- 0
  aridity[aridity >= 0.5] <- 1

  # pasture suitability check
  pastureSuit <- aridity
  popDensity <- popDensity[, getYears(pastureSuit), ]
  pastureSuit[popDensity < 5] <- 0 # 5 hab km2 population threshold for managed pastures. Same from HYDE 3.2.

  ### UNCLEAR IF THIS MAKES SENSE AS IS (with new landArea variable which is in mha)
  pastureSuitArea <- (pastureSuit * landArea * 100) / 1e6 # (from km2 (x100) to mha (/1e6))
  pastureSuitArea <- collapseDim(pastureSuitArea)
  pastureSuitArea <- toolHoldConstantBeyondEnd(pastureSuitArea)

  # calibration to historical values

  histPastr <- setNames(calcOutput("LanduseInitialisation", cellular = TRUE,
                                   nclasses = "nine", aggregate = FALSE)[, , c("past")], "pastr")
  pastAll <- intersect(getYears(histPastr), getYears(pastureSuitArea))

  pastLy <- findset("past")
  pastLy <- pastLy[length(pastLy)] # past last year
  future <- setdiff(getYears(pastureSuitArea), pastAll)

  map <- toolGetMapping("CountryToCellMapping.csv", type = "cell")
  pastureSuitAreaReg <- toolAggregate(pastureSuitArea, rel = map, from = "celliso", to = "iso")
  histPastrReg <- toolAggregate(histPastr, rel = map, from = "celliso", to = "iso")
  calibReg <- histPastrReg[, pastLy, ] / pastureSuitAreaReg[, pastLy, ]
  calibReg[is.infinite(calibReg)] <- 1
  calibReg[is.nan(calibReg)] <- 0
  pastureSuitArea[, future, ] <- toolAggregate(calibReg, rel = map,
                                               from = "iso", to = "celliso") * pastureSuitArea[, future, ]

  pastureSuitArea[is.infinite(pastureSuitArea) | is.nan(pastureSuitArea) | is.na(pastureSuitArea)] <- 0
  pastureSuitArea[pastureSuitArea < 0] <- 0
  pastureSuitArea[, pastAll, ] <- histPastr[, pastAll, ]

  y <- intersect(pastAll, getYears(pastureSuitArea))
  pastureSuitArea[, y, ] <- histPastr[, intersect(pastAll, getYears(pastureSuitArea)), ]
  pastureSuitArea <- toolHoldConstant(pastureSuitArea, findset("time"))
  pastureSuitArea <- collapseNames(pastureSuitArea)
  pastureSuitArea[, pastAll, ] <- histPastr[, pastAll, ]
  #maybe change to: pastureSuitArea[, pastAll, ] <- max(histPastr[, pastAll, ], pastureSuitArea[, pastAll, ]) #nolint
  pastureSuitArea <- setNames(pastureSuitArea, "yields")

  return(list(x            = pastureSuitArea,
              weight       = NULL,
              unit         = "Mha",
              description  = "Area suitable for pasture management in mha",
              isocountries = FALSE))
}

cellPrep
cellPet

cellPrep["BRA",,] |> dimSums(dim = 1) |> plot()
population["BRA",,] |> dimSums(dim = 1)
